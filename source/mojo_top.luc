module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,       // AVR RX buffer full
    output sel[16],
    output seg[8],
    input readyread,
    output readyhigh,
    input aread,
    output ahigh,
    input bread,
    output bhigh,
    input cread,
    output chigh,
    input dread,
    output dhigh,
    output inv1,
    output inv2,
    output inv3,
    output out    
    
  ) {
  sig rst; // reset signal
                
   .clk(clk) {
  
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    .rst(rst){
      multi_seven_seg mseg;
      fsm_main main;
      multi_dec_ctr dec_ctr;
      dff innerclock[25];
      dff lolclock[8];
      dff flag(#INIT(1));
    }
  }
  
  gate_rom gate1;
  gate_rom gate2;
  gate_rom gate3;
  
  
  always {
    ahigh = 1;
    bhigh = 1;
    chigh = 1;
    dhigh = 1;
    readyhigh = 1;
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    main.flag = flag.q;
    dec_ctr.inc = 0;
     innerclock.d = innerclock.q+1;
    if (innerclock.q == b1111111111111111111111111){
      lolclock.d = lolclock.q+1;
      dec_ctr.inc = d10 - lolclock.q;
      innerclock.d = b0000000000000000000000000;
    }
    if(main.delay ==1){
      lolclock.d =b00000000;
    }
    main.threesig = innerclock.q[4:2];
    if(lolclock.q > b00001010 ){
      flag.d = 0;
      lolclock.d = 8b0;
    }
    if(readyread == 1 && aread == 0 && bread == 0 && cread == 0 && dread == 0){
      main.btn_ready = 1;
    }
    else{
      main.btn_ready = 0;
    }
    
    
    main.a = aread;
    main.b = bread;
    main.c = cread;
    main.d = dread;
    gate1.select = 0;
    gate2.select = 0;
    gate3.select = 0;
    case(main.led1){
      000: gate1.select = 0;
      010: gate1.select = 2;
      100: gate1.select = 4;
      110: gate1.select = 6;
    }
    
    case(main.led2){
      000: gate2.select = 0;
      010: gate2.select = 2;
      100: gate2.select = 4;
      110: gate2.select = 6;
    }
    
    case(main.led3){
      000: gate3.select = 0;
      010: gate3.select = 2;
      100: gate3.select = 4;
      110: gate3.select = 6;
    }
    
//    mseg.values = c{gate1.out,gate2.out,gate3.out,dec_ctr.digits};
    
    mseg.values = c{dec_ctr.digits,gate3.out,gate2.out,gate1.out};    
    seg = ~mseg.seg;
    sel = mseg.sel;
    
    inv1 = main.inv11;
    inv2 = main.inv22;
    inv3 = main.inv33;
    out = main.out;
    
    
  }
}